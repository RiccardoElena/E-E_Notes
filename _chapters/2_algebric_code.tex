\chapter{Codici}

Addentrandoci finalmente negli argomenti propri del corso, in questo capitolo si inizieranno a trattare i \keyword{codici}.
In particolare, questo capitolo si concentra sui codici da un punto di vista algebrico, studiandone le proprietà fondamentali e le strutture matematiche sottostanti.

Le loro proprietà legate alla teoria dell'informazione e alla crittografia verranno invece trattate nei capitoli successivi.

\section{Definizione di Codice}
\begin{definition}[Codice]
  Dato \(A\) alfabeto finito, diremo che \(\emptyset \neq X \subseteq A^*\) è un \keyword{codice} se \(X\) è base di (un sottomonoide libero di) \(A^*\)
\end{definition}

\begin{note}
  Come già osservato nella Nota~\ref{note:no_neutral_in_base}, per definizione di base, nessun codice può contenere la parola vuota \(\varepsilon\).
  Di conseguenza, la notazione \(X \subseteq A^*\) può essere sostituita con \(X \subseteq A^+\) se \(X\) è codice.
\end{note}

\begin{definition}[Prefisso e Suffisso]
  Dato \(A\) alfabeto finito, diremo che \(\emptyset \neq X \subseteq A^*\) è
  \begin{description}
    \item[\keyword{Prefisso}] se \(X\cap XA^+ = \emptyset\)
    \item[\keyword{Suffisso}] se \(A^+X \cap X = \emptyset\)
  \end{description}
\end{definition}

In altre parole \(X\) è prefisso se nessuna parola di \(X\) è prefisso di un'altra parola di \(X\), e analogamente per il suffisso.

Il concetto di codice e di prefisso (suffisso) sono strettamente collegati.
È possibile infatti dimostrare due forti risultati a riguardo.
\begin{theorem}
  Sia \(A\) alfabeto finito e \(\emptyset \neq X \subseteq A^*\).
  Allora:
  \begin{enumerate}
    \item \(X\) prefisso (suffisso) è codice \(\iff X \neq {\varepsilon}\)
    \item \(X\) codice è prefisso (suffisso) \(\iff X^*\) unitario a sinistra (destra)
  \end{enumerate}
\end{theorem}
\todo{Altra domanda importante nel codice}
% FIXME @TheFabbest
% Sappiamo che A* è libero, e se X è contenuto in A* allora X* è sottomonoide di A*.
% X* per sua definizione è libero. Ma dall'osservazione che già ci sembrava dubbi prima dovremmo avere che X* è sempre unitario.
% Da quest'ultimo teorema si dovrebbe avere dunque che X è sempre sia prefisso che suffisso
% C'è qualcosa che decisamente non abbiamo capito

\begin{corollary}
  \(\emptyset \neq X \subseteq A^+\) è codice se e solo se valgono entrambe le seguenti condizioni:
  \begin{itemize}
    \item \({(X^*)}^{-1}X^* \cap X{(X^*)}^{-1} \subseteq X^* \)
    \item \(X \cap XX^+ = \emptyset\)
  \end{itemize}
\end{corollary}

\section{Insiemi Resto e Decisione dei Codici}

Dagli insiemi quozienti, definiti nella Definizione~\ref{def:quotien_set}, è possibile definire gli insiemi \emph{resto} da essi derivati.
\begin{definition}[Insiemi resto]
  Per \(X \subseteq A^+\) definiamo la successione di insiemi resto destri come:
  \begin{equation}
    \begin{cases}
      R_1(X) = X^{-1}X\setminus \set{\varepsilon} \\
      R_{n+1}(X) =X^{-1} R_n(X) \cup {R_n(X)}^{-1}X, \quad n \geq 1\\
    \end{cases}
  \end{equation}
  I resti sinistri sono definiti in modo analogo usando il quoziente destro.
\end{definition}

In altre parole, dato \(X \subseteq A^+\), il primo insieme dei resti destri \(R_1(X)\) è l'insieme delle parole che completano a destra una parola di \(X\) per formare un'altra parola di \(X\), escluse le parole vuote.
I resti successivi sono invece le parole che completano a destra una parola di \(X\) per formare una parola del resto precedente o viceversa.
Tali insiemi sono collegati a importanti proprietà dei codici, come vedremo a breve.
\begin{note}
  Se \(X\) è chiaro dal contesto, indicheremo semplicemente con \(R_n\) i suoi insiemi resto.
\end{note}
\begin{example}
  Sia \(A = \set{a,b}, X = \set{a,a^3b,abb,b^3}\).
  Avremo dunque che gli insiemi resto di \(X\) sono:

  \(R_1 = \set{a^2b, bb}\)
  con \(a^2b\) che completa \(a\) per formare \(a^3b\) e \(bb\) che completa sempre \(a\) per formare \(abb\).

  \(R_2 = \set{ab,b}\)
  con \(ab\) che completa sempre \(a\) per formare \(a^2b\) e \(b\) che completa \(bb\) per formare \(b^3\).

  \(R_3 = \set{b,bb}\)
  con \(b\) che completa \(a\) per formare \(ab\) e \(bb\) che completa \(b\) per formare \(bbb\).
  Da questo punto la successione si stabilizza, e dunque \(\forall n \geq 3, R_n = \set{b,bb}\)
\end{example}

È interessante notare che l'\(X\) scelto nell'esempio precedente è un codice, e che i suoi insiemi resto non contengono mai elementi di \(X\).
Questa osservazione non è casuale, ma è in realtà il risultato di un teorema importante.
\begin{theorem}[Sardinas-Patterson]\label{thm:sardinas-patterson}
  Sia \(\emptyset \neq X \subseteq A^+\). Allora \(X\) è codice \(\iff \forall n\geq 1\st R_n(X) \cap X = \emptyset\)
\end{theorem}

Per dimostrare questo teorema, è utile utilizzare un risultato intermedio per semplificare la trattazione.

\begin{lemma}\label{lem:sardinas-patterson-intermediate}
  Sia \(X \subseteq A^+\) e \(n\geq 1\). Allora, data \(w \in A^+\), \(w \in R_n \iff \exists i,j\geq 1, x_1,\ldots,x_i,x_1',\ldots,x_j' \in X\) tali che:
  \begin{itemize}
    \item \(i+j=n+1\)
    \item \(x_1\ldots x_{i}w = x_1'\ldots x_j'\)
    \item \(x_1 \neq x_1'\)
    \item \(\abs{w} \leq \abs{x_j'}\)
  \end{itemize}
\end{lemma}

\begin{proof}
  La dimostrazione procede per induzione su \(n\).
  Il caso base \(n=1\) è vero per definizione di \(R_1\) con \(i = j = 1\).
  Procediamo dunque col passo induttivo nelle due direzioni dell'implicazione.
  \begin{description}
    \item[\q{\(\implies\)}] 
      Sia \(w \in R_n, n>1\). Allora \(R_n = X^{-1}R_{n-1} \cup {R_{n-1}}^{-1}X\), dunque
      \[\exists r_{n-1} \in R_{n-1}, x \in X: xw=r_{n-1} \lor r_{n-1}w=x\]

      Per ipotesi induttiva, esistono \(i,j \geq 1, x_1\ldots x_i,x_1'\ldots x_j' \in X\) tali che:
      \begin{itemize}
        \item \(i+j=n+1\)
        \item \(x_1\ldots x_i r_{n-1} = x_1'\ldots x_j'\)
        \item \(x_1 \neq x_1'\)
        \item \(\abs{r_{n-1}} \leq \abs{x_j'}\)
      \end{itemize}
      Ora, se \(xw = r_{n-1}\), si ha che \(x_1\ldots x_i xw= x_1\ldots x_i r_{n-1} = x_1'\ldots x_j'\), da cui \(i+1,j\), e scegliendo come \(x_{i+1} = x\) si ha che tutte le condizioni sono soddisfatte.
      Le prime tre condizioni sono ovvie, e l'ultima è data da \(\abs{w}\leq\abs{r_{n-1}}\leq\abs{x_j'}\).
      Se invece \(r_{n-1}w = x\), otteniamo \(x_1\ldots x_i r_{n-1} w = x_1'\ldots x_j' w\) concatenando \(w\) a destra di entrambi i membri.
      Ma sapendo che \(r_{n-1}w = x\), possiamo riscrivere gli ultimi due fattori del primo membro come \(x\), ottenendo \(x_1\ldots x_i x = x_1'\ldots x_j' w\).
      In questo caso, scegliendo \(j,i+1\) e \(x_j' = x\) otteniamo nuovamente tutte le condizioni.
    \item[\q{\(\impliedby\)}]
      In questa direzione dell'implicazione, supponiamo che esistano \(i,j \geq 1\), \(x_1\ldots x_i,x_1'\ldots x_j'\) parole di \(X\) e \(w\in A^+\) che soddisfano le condizioni elencate.
      Possiamo dunque procedere per casi:
      \begin{enumerate}
        \item \(\abs{x_{i}w} \leq \abs{x_j'}\):
          In questo caso, certamente si avrà che \(i>1\). Questo poiché, se \(i\) fosse uguale a \(1\), per \(j=1\) ci si riconduce al caso base trattato precedentemente e per \(j>1\) si ottiene una contraddizione.
          Infatti, se \(i=1\) e \(j>1\), si avrebbe che \(x_{i=1} w = x_1'\ldots x_j'\), da cui \(\abs{x_{i}w} > x_j'\), in contraddizione con l'ipotesi.

          Ciò ci permette di porre \(r_{n-1} = x_{i}w\). Dall'ipotesi induttiva, sappiamo che \(r_{n-1} \in R_{n-1}\), poiché:
          \begin{enumerate}
            \item \(x_1\ldots x_{i-1}r_{n-1} = x_1'\ldots x_j'\), sostituendo \(r_{n-1}\) a \(x_{i}w\)
            \item \(i-1+j=n\)
            \item \(x_1 \neq x_1'\)
            \item \(\abs{r_{n-1}} = \abs{x_i w} \leq \abs{x_j'}\)
          \end{enumerate}
          Ma per com'è stato definito \(r_{n-1}\), si ha che \(w \in R_n\) poiché \(x_{i} w = r_{n-1}\) implica che \(w \in X^{-1} R_{n-1} \subseteq R_n\).
        \item \(\abs{x_{i}w} > \abs{x_j'}\):
          In questo caso, specularmente al caso precedente, possiamo escludere che \(j=1\).
          Sappiamo infatti per ipotesi dell'implicazione che \(\abs{w} \leq \abs{x_j'}\) e che \(x_1\ldots x_i w = x_1'\ldots x_j'\). Usando il Teorema di Levi (\ref{thm:levi}), ponendo come \(m_1 = x_1\ldots x_i\), \(m_2 = w\), \(m_3 = x_1'\ldots x_{j-1}'\) e \(m_4 = x_j'\), otteniamo che esiste \(v \in A^*\) tale che \(vw=x_j'\).
          Possiamo sostituire \(vw\) a \(x_j'\) nell'uguaglianza di parole ottenendo:
          \[x_1\ldots x_i w = x_1'\ldots x_{j-1}' vw \implies x_1\ldots x_i = x_1'\ldots x_{j-1}' v \]
          Ora, se \(j=1\), si avrebbe che 
            \[x_1\ldots x_i = v \implies \abs{x_i} \leq \abs{v} \implies \abs{x_i w} \leq \abs{vw} = \abs{x_j'} \]
          che contraddice l'ipotesi che \(\abs{x_{i}w} > \abs{x_j'}\).\footnote{L'implicazioni seguono dal fatto che \(||\) è un morfismo in \((\N,+,0)\), dunque \(\abs{vw} = \abs{v}+\abs{w} \forall v,w \in A^*\). Di conseguenza, sommando \(\abs{w}\) a entrambe i membri dell'ultima disuguaglianza il verso non cambia.}
          Da questa costruzione, possiamo notare come, per ipotesi induttiva, \(v\) debba appartenere a \(R_{n-1}\), infatti:
          \begin{enumerate}
            \item \(x_1'\ldots x_{j-1}' v = x_1\ldots x_i\)
            \item \(i + (j-1) = n\)
            \item \(x_1 \neq x_1'\)
            \item \(\abs{v} \leq \abs{x_j'}\), poiché da \(vw = x_j'\) si ha che \(\abs{v} = \abs{x_j'} - \abs{w} \leq \abs{x_j'}\)
        \end{enumerate}
        Similmente a prima, per come è stato definito \(v\), si ha che \(w \in R_n\) poiché \(vw = x_j'\) implica che \(w \in {R_{n-1}}^{-1} X \subseteq R_n\).
      \end{enumerate}
  \end{description}
\end{proof}

Conclusa la dimostrazione del lemma, possiamo procedere con la dimostrazione del Teorema di Sardinas-Patterson.
\begin{proof}[Dimostrazione (\ref{thm:sardinas-patterson})]
  Per questa dimostrazione, procederemo mostrando come la condizione equivalente ottenuta negando entrambe le parti della doppia implicazione sia vera.
  In altre parole, mostreremo che l'equivalenza:
  \[X \text{ non è codice } \iff \exists n \geq 1 \st R_n \cap X \neq \emptyset\]
  è valida.

  Dalla definizione di codice, sappiamo che 
  \[X \text{ non è codice } \iff \exists x_1, \ldots, x_h,x_1',\ldots,x_k' \in X \st x_1\ldots x_h = x_1'\ldots x_k' \land x_1 \neq x_1'\]
  
  Possiamo scegliere \(x_1\) e \(x_1'\) come parole diverse nella fattorizzazione senza perdita di generalità per minimalità.
  Non fossero diverse, potremmo \qi{cancellarle} da entrambi i membri della fattorizzazione, ottenendo una nuova parola con multipla fattorizzazione più corta.
  
  Di conseguenza, necessariamente \(h\) e \(k\) non possono essere entrambi uguali a \(1\), o equivalentemente \(h>1 \lor k>1\).
  Supponiamo, sempre senza perdita di generalità, che \(h>1\).
  Dal Lemma~\ref{lem:sardinas-patterson-intermediate}, abbiamo che \(x_h \in R_n\), dove \(n = h + k - 2 \geq 1\).
  Infatti, ponendo \(w = x_h\), si ha che:
  \begin{enumerate}
    \item \(i = h - 1, j = k\) soddisfano \(i + j = n + 1\)
    \item \(x_1\ldots x_{h-1} x_h = x_1'\ldots x_k'\) per ipotesi
    \item \(x_1 \neq x_1'\) per scelta
    \item \(\abs{w} = \abs{x_h} \leq \abs{x_k'}\) poiché, essendo \(h>1\) è sempre possibile scegliere come \(x_k'\) una parola più lunga di \(x_h\) nella fattorizzazione, concatenando a destra parole di \(X\) fino a superarne la lunghezza.
      Se infatti \(\abs{x_h} > \abs{x_k'}\), possiamo prendere come \(x_k'' =  x_{k-1}'x_k'\) che sostituito a \(x_k'\) nella fattorizzazione mantiene l'uguaglianza, ma ha lunghezza maggiore di \(x_k'\). Non fosse sufficiente, possiamo ripetere il procedimento concatenando altre parole di \(X\) a sinistra fino a superare la lunghezza di \(x_h\), la quale è necessariamente inferiore alla lunghezza dell'intera parola dell'uguaglianza.
      Al limite, è possibile scegliere \(k=1\), per cui \(x_{k=1}' = x_1\ldots x_h \implies \abs{x_h}\leq\abs{x_k} \)
  \end{enumerate}
  Essendo \(x_h\) appartenente sia a \(X\) che a \(R_n\) sopra definito, abbiamo che \(X\) non codice \(\implies \exists n \geq 1 \st R_n \cap X \neq \emptyset\).
  Viceversa, \(\exists n \geq 1 \st R_n \cap X \neq \emptyset \implies \exists x \in R_n \cap X\).
  Tale \(x\) appartiene a \(R_n\), dunque per il Lemma~\ref{lem:sardinas-patterson-intermediate} esistono opportuni \(i,j \geq 1\) e \(x_1,\ldots,x_i,x_1',\ldots,x_j' \in X\) tali che valgano le condizioni elencate, in particolare che \(x_1\ldots x_i x = x_1'\ldots x_j'\) e \(x_1 \neq x_1'\), ovvero che \(X\) non è codice.
\end{proof}

\begin{note}[Osservazioni]
  \begin{itemize}
    \item \(X \text{codice prefisso} \iff R_1 = \emptyset\).
      Questo poiché dalla definizione di prefisso si ha che \(X \cap XA^+ = \emptyset \iff X^{-1}X \setminus \set{\varepsilon} = \emptyset\)
    \item \(X \text{codice} \iff \forall n \geq 1 L_n \cap X = \emptyset\),
      dove \(L_n\) sono gli insiemi resto sinistri di \(X\).
      La dimostrazione è analoga a quella del Teorema di Sardinas-Patterson, utilizzando il corrispondente lemma per gli insiemi resto sinistri.
  \end{itemize}
\end{note}

\begin{example}
  Sia \(X_2 = \set{a,ab,bb}\). Calcoliamo gli insiemi resto di \(X_2\):

  \(R_1 = X_2^{-1}X_2 \setminus \set{\varepsilon} = \set{b}\)
  poiché \(b\) completa \(a\) per formare \(ab\).

  \(R_2 = X_2^{-1}R_1 \cup R_1^{-1}X_2 = \set{b}\)
  poiché \(b\) completa \(a\) per formare \(ab\) e \(b\) completa \(bb\) per formare \(bb\).

  Da questo punto in poi, la successione si stabilizza, dunque \(\forall n \geq 1, R_n = \set{b}\).
  Poiché \(b \not\in X_2\), per il Teorema di Sardinas-Patterson, \(X_2\) è codice.

  Sia \(X_4 = \set{a,aba,bb}\). Calcoliamo gli insiemi resto di \(X_4\):
  
  \(R_1 = X_4^{-1}X_4 \setminus \set{\varepsilon} = \set{ba}\)
  poiché \(ba\) completa \(a\) per formare \(aba\).

  \(R_2 = X_4^{-1}R_1 \cup R_1^{-1}X_4 = \emptyset\)
  poiché nessuna parola di \(X_4\) può essere usata per completare \(ba\) e viceversa.
  
  Da questo punto in poi, la successione si stabilizza, dunque \(\forall n \geq 2, R_n = \emptyset\).
  Anche in questo caso, \(X_4\) è codice per il Teorema di Sardinas-Patterson.

  Sia infine \(X_5 = \set{a,ab,ba}\). Calcoliamo gli insiemi resto di \(X_5\):

  \(R_1 = X_5^{-1}X_5 \setminus \set{\varepsilon} = \set{b}\)
  poiché \(b\) completa \(a\) per formare \(ab\).
  
  \(R_2 = X_5^{-1}R_1 \cup R_1^{-1}X_5 = \set{a}\)
  poiché \(a\) completa \(b\) per formare \(ba\).
  Dunque, essendo che \(a \in X_5\), per il Teorema di Sardinas-Patterson, \(X_5\) non è codice.
\end{example}

Da questi risultati, si potrebbe evincere che il teorema di Sardinas-Patterson (\ref{thm:sardinas-patterson}) fornisca una procedura di decisione per stabilire se un insieme \(X \subseteq A^+\) \textbf{finito} sia codice o meno.
Tuttavia, in linea di principio, il teorema fornisce solo una procedura di semi-decisione poiché, se \(X\) non è codice, esisterà sempre un \(n\) tale che \(R_n \cap X \neq \emptyset\) portando alla terminazione dell'algoritmo, ma se \(X\) è codice, non è detto che la successione degli insiemi resto si stabilizzi mai, costringendo l'algoritmo a verificare indefinitamente.

In realtà, è possibile definire una procedura di decisione basata sul Teorema di Sardinas-Patterson.
I risultati seguenti saranno necessari a questo scopo.
\begin{proposition}\label{prop:rest_sets_subset_suffix}
  Sia \(X \subseteq A^*\). Allora \(\forall n \geq 1, R_n(X) \subseteq Suff(X)\), ovvero ogni insieme resto è contenuto nell'insieme dei suffissi di \(X\).
\end{proposition}
\begin{proof}
  Procediamo per induzione su \(n\).
  Il caso base \(n=1\) è banale, per definizione di \(R_1\).

  Per \(n>1, R_n(X)=X^{-1}R_{n-1}(X) \cup {R_{n-1}(X)}^{-1}X\); quindi, \(r_n \in R_n \implies \exists x \in X, r_{n-1}\in R_{n-1}(X) \st r_{n-1}r_n = x \lor xr_n = r_{n-1}\).
  Nel primo caso, \(r_n\) è suffisso di \(x \in X\) per definizione di suffisso.
  Nel secondo caso, \(r_{n}\) è suffisso di \(r_{n-1}\), che per ipotesi induttiva è suffisso di una parola di \(X\), dunque anche \(r_n\) è suffisso di una parola di \(X\) essendo la relazione di suffisso una relazione d'ordine, e in particolare transitiva.
\end{proof}

Questo risultato implica che, dato un insieme finito \(X\), la procedura di decisione descritta precedentemente avrà sempre termine poiché gli insiemi resto \(R_n\) potranno assumere solo un numero finito di valori, essendo contenuti nell'insieme, anch'esso finito, \(Suff(X)\).

Inoltre, denotando \(K = \# X\) e \(L = \max_{x \in X} \abs{x}\), si ha che \(\# Suff(X) \leq KL+1\).
Infatti, ogni \( x \in X \setminus \set{\varepsilon}\) ha esattamente \(\abs{x}\) suffissi non vuoti distinti e quindi \(X\), che ha \(K\) parole di lunghezza al più \(L\), avrà al più \(KL\) suffissi non vuoti distinti, a cui si deve aggiungere la parola vuota \(\varepsilon\) come suffisso banale.

Di conseguenza, \(Suff(X)\) ha al più \(2^{KL+1}\) sottoinsiemi\footnote{\(\#(\P(S)) = 2^{\#S}\) è un risultato noto in combinatoria}, per cui \(\exists n \leq 2^{KL+1} \st R_n = R_m, m < n\), e conseguentemente \(R_{n+i} = R_{m+i}, \forall i \geq 0\), ovvero la successione degli insiemi resto si stabilizza entro un numero finito di passi, esponenziale in \(K\) e \(L\).
Chiaramente tale limite è molto elevato, portando a complessità esponenziale nell'algoritmo di decisione basato sul Teorema di Sardinas-Patterson.
Fortunatamente, è possibile mostrare come tale limite possa essere notevolmente ridotto, portando la complessità dell'algoritmo a essere lineare in \(K\) e \(L\).
\begin{theorem}[Levanshtein???]
  Sia \(\emptyset \neq X \subseteq A^+\) finito e siano \(K = \# X\) e \(L = \max_{x \in X} \abs{x}\).
  Allora, \(X \text{ è codice } \iff \forall n \leq KL +1, R_n \cap X = \emptyset\)
\end{theorem}

In poche parole, questo teorema afferma che, nel caso di insiemi finiti, se le condizioni del Teorema di Sardinas-Patterson sono verificate per i primi \(KL+1\) insiemi resto, allora lo saranno per tutti gli insiemi resto successivi.

\begin{proof}
  Per questa dimostrazione, sarà sufficiente dimostrare esclusivamente la direzione \(\impliedby\) della doppia implicazione, poiché l'altra direzione è ovvia per il Teorema di Sardinas-Patterson (\ref{thm:sardinas-patterson}).
  Procediamo dunque per assurdo, supponendo che \(X\) non sia codice. Allora per~\ref{thm:sardinas-patterson} \(\exists m > KL + 1 \st R_m \cap X \neq \emptyset\).
  Scegliamo, senza perdita di generalità, tale \(m\) come il minimo intero che soddisfa questa proprietà.
  Sia dunque \(r_m \in R_m \cap X\). Per definizione di insieme resto, esistono \(x,x',x_1,\ldots,x_m \in X, r_1\in R_1,\ldots,r_{m-1} \in R_{m-1}\) tali che:
  \begin{itemize}
    \item \(xr_1=x'\) 
    \item \(\forall i \in \set{2,\ldots,m} r_{i-1}r_i=x_i \lor xr_i = r_{i-1}\)
  \end{itemize}
  Ma dalla Proposizione~\ref{prop:rest_sets_subset_suffix}, sappiamo che \(r_1,\ldots,r_m \in Suff(X)\), e dall'osservazione precedente sappiamo che \(\# Suff(X) \leq KL + 1 < m\).
  Dunque, per il principio della piccionaia, \(\exists i,j \st r_i=r_j\). Supponiamo senza perdita di generalità che \(i<j\).
  Si ha dunque che \(r_j \in R_i\), da cui segue che \(r_{j+1} \in R_{i+1}\) e così via fino a \(r_m \in R_{m-(j-i)}\).
  Ma questo implica che \(R_{m-(j-i)} \cap X \neq \emptyset\), in contraddizione con la scelta di \(m\) come minimo intero tale che \(R_m \cap X \neq \emptyset\).
\end{proof}

\begin{example}
  Poniamo \(X = \set{a,a^3b,ab^2,b^3}\). Calcoliamo gli insiemi resto di \(X\):
  \[R_1 = \set{a^2b,b^2}\]
  \[R_2 = \set{ab,b}\]
  \[R_3 = \set{b,bb} = R_n \forall n \geq 3\]
  In questo caso è stato sufficiente calcolare i primi \(3\) insiemi resto per stabilire che \(X\) è codice, ma in ogni caso ci sarebbe bastato calcolare i primi \(KL+1 = 4\cdot 4 + 1 = 17\).
  Prendendo invece \(X_5 = \set{a,ab,ba}\) come nell'esempio precedente, avevamo che \(a \in R_2\), ma in ogni caso sarebbe stato sufficiente calcolare i primi \(KL+1 = 3\cdot 2 + 1 = 7\) insiemi resto.
\end{example}

Questi esempi servono a mostrare come in molti caso questo nuovo limite sia comunque più grande del necessario, ma in ogni caso fornisce una procedura di decisione efficiente per stabilire se un insieme finito sia codice o meno.

\section{Distribuzioni e Disuguaglianza di Kraft-McMillan}

\section{Codici Massimali e Insiemi Densi e Completi}
% TODO @TheFabbest
% Questa è la sezione di cui tu hai fatto le foto e non ci sono lavagne, dovresti vedere se riesci a scriverla tu

% Dopo questa sezione (che corrisponde alla lezione 6 del 6 ottobre) siamo "in pari" col file draft, nel senso che quello che viene dopo è già scritto nel file draft e va solo ripulito.
% Dopo tale file poi ci sono i tuoi appunti in obsidian da trascrivere delle lezioni in cui ero in finlandia.
% Fatto ciò siamo in pari