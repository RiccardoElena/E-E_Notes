\chapter{Codici}

Addentrandoci finalmente negli argomenti propri del corso, in questo capitolo si inizieranno a trattare i \keyword{codici}.
In particolare, questo capitolo si concentra sui codici da un punto di vista algebrico, studiandone le proprietà fondamentali e le strutture matematiche sottostanti.

Le loro proprietà legate alla teoria dell'informazione e alla crittografia verranno invece trattate nei capitoli successivi.

\section{Definizione di Codice}
\begin{definition}[Codice]
  Dato \(A\) alfabeto finito, diremo che \(\emptyset \neq X \subseteq A^*\) è un \keyword{codice} se \(X\) è base di (un sottomonoide libero di) \(A^*\)
\end{definition}

\begin{note}
  Come già osservato nella Nota~\ref{note:no_neutral_in_base}, per definizione di base, nessun codice può contenere la parola vuota \(\varepsilon\).
  Di conseguenza, la notazione \(X \subseteq A^*\) può essere sostituita con \(X \subseteq A^+\) se \(X\) è codice.
\end{note}

\begin{definition}[Prefisso e Suffisso]
  Dato \(A\) alfabeto finito, diremo che \(\emptyset \neq X \subseteq A^*\) è
  \begin{description}
    \item[\keyword{Prefisso}] se \(X\cap XA^+ = \emptyset\)
    \item[\keyword{Suffisso}] se \(A^+X \cap X = \emptyset\)
  \end{description}
\end{definition}

In altre parole \(X\) è prefisso se nessuna parola di \(X\) è prefisso di un'altra parola di \(X\), e analogamente per il suffisso.

Il concetto di codice e di prefisso (suffisso) sono strettamente collegati.
È possibile infatti dimostrare due forti risultati a riguardo.
\begin{theorem}
  Sia \(A\) alfabeto finito e \(\emptyset \neq X \subseteq A^*\).
  Allora:
  \begin{enumerate}
    \item \(X\) prefisso (suffisso) è codice \(\iff X \neq {\varepsilon}\)
    \item \(X\) codice è prefisso (suffisso) \(\iff X^*\) unitario a sinistra (destra)
  \end{enumerate}
\end{theorem}
\todo{Altra domanda importante nel codice}
% FIXME @TheFabbest
% Sappiamo che A* è libero, e se X è contenuto in A* allora X* è sottomonoide di A*.
% X* per sua definizione è libero. Ma dall'osservazione che già ci sembrava dubbi prima dovremmo avere che X* è sempre unitario.
% Da quest'ultimo teorema si dovrebbe avere dunque che X è sempre sia prefisso che suffisso
% C'è qualcosa che decisamente non abbiamo capito

\begin{corollary}
  \(\emptyset \neq X \subseteq A^+\) è codice se e solo se valgono entrambe le seguenti condizioni:
  \begin{itemize}
    \item \({(X^*)}^{-1}X^* \cap X{(X^*)}^{-1} \subseteq X^* \)
    \item \(X \cap XX^+ = \emptyset\)
  \end{itemize}
\end{corollary}

\section{Proprietà dei codici}

Dagli insiemi quozienti, definiti nella Definizione~\ref{def:quotien_set}, è possibile definire gli insiemi \emph{resto} da essi derivati.
\begin{definition}[Insiemi resto]
  Per \(X \subseteq A^+\) definiamo la successione di insiemi resto destri come:
  \begin{equation}
    \begin{cases}
      R_1(X) = X^{-1}X\setminus \set{\varepsilon} \\
      R_{n+1}(X) =X^{-1} R_n(X) \cup {R_n(X)}^{-1}X, \quad n \geq 1\\
    \end{cases}
  \end{equation}
  I resti sinistri sono definiti in modo analogo usando il quoziente destro.
\end{definition}

In altre parole, dato \(X \subseteq A^+\), il primo insieme dei resti destri \(R_1(X)\) è l'insieme delle parole che completano a destra una parola di \(X\) per formare un'altra parola di \(X\), escluse le parole vuote.
I resti successivi sono invece le parole che completano a destra una parola di \(X\) per formare una parola del resto precedente o viceversa.
Tali insiemi sono collegati a importanti proprietà dei codici, come vedremo a breve.
\begin{note}
  Se \(X\) è chiaro dal contesto, indicheremo semplicemente con \(R_n\) i suoi insiemi resto.
\end{note}
\begin{example}
  Sia \(A = \set{a,b}, X = \set{a,a^3b,abb,b^3}\).
  Avremo dunque che gli insiemi resto di \(X\) sono:
  \[R_1 = \set{a^2b, bb}\]
  con \(a^2b\) che completa \(a\) per formare \(a^3b\) e \(bb\) che completa sempre \(a\) per formare \(abb\).
  \[R_2 = \set{ab,b}\]
  con \(a^b\) che completa sempre \(a\) per formare \(a^2b\) e \(b\) che completa \(bb\) per formare \(b^3\).
  \[R_3 = \set{b,bb}\]
  con \(b\) che completa \(a\) per formare \(ab\) e \(bb\) che completa \(b\) per formare \(bbb\).
  Da questo punto la successione si stabilizza, e dunque:
  \[\forall n \geq 3, R_n = \set{b,bb}\]
\end{example}

È interessante notare che l'\(X\) scelto nell'esempio precedente è un codice, e che i suoi insiemi resto non contengono mai elementi di \(X\).
Questa osservazione non è casuale, ma è in realtà il risultato di un teorema importante.
\begin{theorem}[Sardinas-Patterson]
  Sia \(\emptyset \neq X \subseteq A^+\). Allora \(X\) è codice \(\iff \forall n\geq 1 R_n(X) \cap X = \emptyset\)
\end{theorem}

\todo{Secondo me qui un idea di dim la si può pensare}

% ?? @TheFabbest
% Fino a dove sono arrivato non è ben chiaro se il lemma che segue serve a dimosrtare il teorema di Sardinas-Patterson o se tale teorema non verrà dimostrato.
% Nel primo caso vanno aggiunte due paroline sul fatto che la dimotrazione arriverà più avanti ma ci servono risultati intermedi. 
\begin{lemma}
  Sia \(X \subseteq A^+\) e \(n\geq 1\). Allora, data \(w \in A^+\), \(w \in R_n \iff \exists i,j\geq 1, x_1,\ldots,x_i,x_1',\ldots,x_j' \in X\) tali che:
  \begin{itemize}
    \item \(i+j=n+1\)
    \item \(x_1\ldots x_{i}w = x_1'\ldots x_j'\)
    \item \(x_1 \neq x_1'\)
    \item \(\abs{w} \leq \abs{x_j'}\)
  \end{itemize}
\end{lemma}

\begin{proof}
  La dimostrazione procede per induzione su \(n\).
  Il caso base \(n=1\) è vero per definizione di \(R_1\) con \(i = j = 1\).
  Procediamo dunque col passo induttivo nelle due direzioni dell'implicazione.
  \begin{description}
    \item[\q{\(\implies\)}] 
      Sia \(w \in R_n, n>1\). Allora \(R_n = X^{-1}R_{n-1} \cup {R_{n-1}}^{-1}X\), dunque
      \[\exists r_{n-1} \in R_{n-1}, x \in X: xw=r_{n-1} \lor r_{n-1}w=x\]

      Per ipotesi induttiva, esistono \(i,j \geq 1, x_1\ldots x_i,x_1'\ldots x_j' \in X\) tali che:
      \begin{itemize}
        \item \(i+j=n+1\)
        \item \(x_1\ldots x_i r_{n-1} = x_1'\ldots x_j'\)
        \item \(x_1 \neq x_1'\)
        \item \(\abs{r_{n-1}} \leq \abs{x_j'}\)
      \end{itemize}
      Ora, se \(xw = r_{n-1}\), si ha che \(x_1\ldots x_i xw= x_1\ldots x_i r_{n-1} = x_1'\ldots x_j'\), da cui \(i+1,j\), e scegliendo come \(x_{i+1} = x\) si ha che tutte le condizioni sono soddisfatte.
      Le prime tre condizioni sono ovvie, e l'ultima è data da \(\abs{w}\leq\abs{r_{n-1}}\leq\abs{x_j'}\).
      Se invece \(r_{n-1}w = x\), otteniamo \(x_1\ldots x_i r_{n-1} w = x_1'\ldots x_j' w\) concatenando \(w\) a destra di entrambi i membri.
      Ma sapendo che \(r_{n-1}w = x\), possiamo riscrivere gli ultimi due fattori del primo membro come \(x\), ottenendo \(x_1\ldots x_i x = x_1'\ldots x_j' w\).
      In questo caso, scegliendo \(j,i+1\) e \(x_j' = x\) otteniamo nuovamente tutte le condizioni.
    \item[\q{\(\impliedby\)}]
      In questa direzione dell'implicazione, supponiamo che esistano \(i,j \geq 1, x_1\ldots x_i,x_1'\ldots x_j' \in X,w\in A^+\) che soddisfano le condizioni elencate.
      Possiamo dunque procedere per casi:
      \begin{enumerate}
        \item \(\abs{x_{i}w} \leq \abs{x_j'}\):
          In questo caso, certamente si avrà che \(i>1\). Questo poiché per \(j=1\) ci si riconduce al caso base trattato precedentemente.
      \end{enumerate}
  \end{description}
\end{proof}