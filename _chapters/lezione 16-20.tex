----------------------------------
LEZIONE 16 OTTOBRE
ci dedichiamo ai codici prefissi

X insieme di parole è prefisso $\iff$ X intersecato XA^+ = vuoto
Se X è prefisso $\implies$  X codice $\iff$ X $\neq {\epsilon}$

Casi particolari:
* codici bifissi (sia prefissi che suffissi)
* sotto caso dei bifissi -> codici uniformi (???)

Dato alfabeto $A=(a_1...a_d)$ con $\#A=d \ge 2$, consideriamo l'albero generale d-ario

epsilon radice
a1 ....                            a2 ....                          ad
$a1^2$ a1a2 ... a1ad     a2a1 a2a2....a2ad          ....
![[Pasted image 20251016165601.png]]

Dato un nodo etichettato con w, i prefissi di w etichettano tutti e soli i nodi tra $\epsilon$ e $w$; viceversa, il sottoalbero radicato in w ha per etichette le estensioni di w, cioè $\{w\}A^*$
Qualunque albero d-ario radicato in $\epsilon$ si ottiene da quello generale "potando" alcuni sottoalberi radicati in dei nodi (che diventano foglie).

Proposizione
X contenuto in A* prefisso $\iff$ X è l'insieme delle (etichette delle) foglie di un albero d-ario
X codice contenuto in A* prefisso $\iff$ X è l'insieme delle (etichette delle) foglie di un albero d-ario di profondità > 0

"un albero" : tale rappresentazione non è univoca, ad esempio per A={a,b} e X={a,bb}, X etichetta le foglie di entrambi gli alberi
![[Pasted image 20251016165554.png]]

Tuttavia, è unico l'albero minimale $T_x$ che rappresenta X, i cui nodi sono esattamente etichettati con gli elementi di Pref(X).

Definiamo "completo" un albero d-ario se ogni nodo interno (cioè che non sia una foglia) ha esattamente d figli.
(ad esempio, l'albero minimale per X={a,bb}, cioè il primo dell'immagine precedente, non è completo)

X codice prefisso su A è definito "codice prefisso massimale" se non è contenuto in nessun altro codice prefisso (analogo a codice massimale normale, ma limitando la "ricerca" ai soli codici prefissi)

Teorema
Sia X codice prefisso su A, $\#A=d \ge 2$, sono equivalenti:
1) X è prefisso massimale
2) $T_X$ è completo
3) X completo a destra

Dimostrazioni

$1\implies 2$
Supponiamo che $T_X$ non sia completo, allora esiste un nodo interno che non ha grado massimo.
Perché X è prefisso massimale, allora $w \in Pref(X)$.
Esiste $a \in A$ tale che $wa \notin X$.
Ma allora $X\cup {wa}$ corrisponde alle etichette di un albero d-ario, cioè è un codice prefisso: quindi X non è massimale
 
$2 \implies 3$
Sia $T_X$ completo e sia $w \in A^*$.
Se $w \in Pref(X)$, evidentemente si completa a destra in X incluso in X*.
Se invece $w \notin Pref(X)$ andiamo a considerare il più grande prefisso di w che sia un prefisso in $Pref(X)$, chiamiamolo $x$. Poiché $T_X$ è completo, x è una foglia e quindi $x \in X$, altrimenti non sarebbe il più lungo prefisso di w.
Sia $w=xw_1$ per qualche $w_1 \in A^*$.
Se $w_1 \in Pref(X)$, allora $w_1$ si completa in X e quindi $w=xw_1$ si completa in $X^2$ sottoinsieme di X*.
Altrimenti itero: sia $x_1$ il più lungo prefisso di $w_1$ che è in Pref(X); per la completezza di $T_X$ si ha $x_1 \in X$, e allora $w_1=x_1w_2 \implies w=xw_1=xx_1w_2$ e così via.
In generale se $w=xx_1...x_iw_{i+1}$ e $w_{i+1}\in Pref(X)$ allora w si completa a destra in $X^{i+1}$ ; altrimenti $w_{i+1}=x_{i+1}w_{i+2}$ ecc.
Ma $|w| \gt |w_1| \gt |w_2| \gt ...$ e dunque tale algoritmo ha termine. In particolare, termina quando $|w_i| \lt min_{x\in X}|x|$, allora $w_i \in Pref(X)$ necessariamente.

$3 \implies 1$
(in realtà dimostriamo not 1 => not 3)
Sia X non massimale, e sia $w \in A^*\setminus X$ tale che $X \cup {w}$ prefisso
Allora w non si completa a destra in $X^*$: se per assurdo si completasse, cioè avessimo ${w}A^*\cap X^* \neq \emptyset$ , allora 
![[Pasted image 20251016172905.png]]

Corollario
Sia X codice prefisso non denso su A (d-ario). Sono equivalenti:
1) X prefisso massimale
2) X completo a destra
3) X completo
4) Per ogni $\mu$ distribuzione positiva su A, $\mu(X) = 1$
5) Esiste una distribuzione positiva $\mu$ su A tale che $\mu(X)=1$
6) X massimale (come codice)

Abbiamo visto che Kraft-McM si può esprimere dicendo che: X è codice $\implies \sum f_X(n)d^{-n} \le 1$
"in un certo senso si può invertire Kraft-McM"
Se un insieme soddisfa la disequazione, non possiamo concludere che X sia codice, ma che quella funzione sia una struttura di un certo insieme che è codice.

Teorema (kraft)
Sia $d\ge 1$ un intero e $f:N \to N$ tale che $f(0)=0$ e $\sum f(n) d^{-n} \le 1$.
Allora esiste X codice prefisso su un alfabeto A con $\#A=d$ tale che $f_X=f$.

Osservazione: se X codice, $f_X(0)=0$. Quindi il teorema di Kraft si può esprimere (alla luce della disuguaglianza di Kraft-McM) dicendo che $f:N \to N$ è funzione di struttura di un codice su un alfabeto d-ario $\iff f(0) = 0 \land \sum f(n)d^{-n} \le 1$

Dimostrazione Kraft
Sia $k\ge 1$. Allora $\sum_{n=0}^k f(n)d^{-n} \le \sum f(n)d^{-n} \le 1 \implies f(K)d^{-k} + \sum_{n=0}^{k-1}f(n)d^{-n} \le 1 \implies f(k) \le d^k - \sum_{n=0}^{k-1}f(n)d^{k-n}$

Chiamiamo $v(k)=d^k-\sum_{n=0}^{k-1}f(n)d^{k-n}$
![[Pasted image 20251016180444.png]]

Inoltre
![[Pasted image 20251016180630.png]]

![[Pasted image 20251016180756.png]]
Considerando l'albero generale d-ario, possiamo quindi scegliere f(1) nodi al primo livello e potarne i sottoalberi corrispondenti, rendendo tali nodi foglie.
Ognuno dei d-f(1) figli rimanenti al primo livello ha d figli al secondo, e d(d-f(1)) = d(v(1)-f(2)) = v(2): tra di essi possiamo sceglierne f(2), che è $\le v(2)$ e renderli foglie, eccetera: in generale ad ogni livello k scelgo f(k) nodi dall'insieme dei v(k) rimasti e li rendo foglie. Itero potenzialmente all'infinito. L'albero così costruito ha quindi esattamente f(k) foglie al livello k per ogni k, e dunque corrisponde ad un codice prefisso su un alfabeto d-ario con f come struttura.


Esempio
f(0)=0, f(1)=1=f(2), f(3) = 3, f(k)=0 per $k\ge 4$

Allora $\sum f(n)2^{-n}=1/2 +1/4 + 3/8 = 9/8 \gt 1$
Non può esistere codice binario con questa funzione di struttura (per disuguaglianza di K-McM).

Inoltre, $\sum f(n)3^{-n} = 1/3 + 1/9 + 3/27 = 5/9 \lt 1$
Quindi, per Kraft, esiste un codice ternario con quella stessa funzione di struttura.

![[Pasted image 20251016182421.png]]


Corollario
Dato X codice su A, esiste Z codice prefisso con la stessa struttura $f_Z=f_X$.

Dimostrazione
Segue da disuguaglianza di K-McM e teorema di Kraft.






----------------
LEZIONE 20 OTTOBRE
Giovedì né lunedì lezione
Giovedì dopo in remoto. forse lunedì dopo non ci sarà ancora.

Ci eravamo lasciati con: dato un codice qualsiasi esiste sempre un codice prefisso con la stessa struttura
Prop.
Dato $X$ contenuto in $A^+$ codice, esiste Z codice prefisso su A tale che $f_X=f_Z$

Prop.
Dato $X$ in $A^+$ codice adattato a $\mathcal{S}$, esiste $Z$ codice prefisso adattato a S tale che $c(X)=c(Z)$

Dim
Preso Z prefisso tale che $f_X=f_Z$ , dato che hanno lo stesso numero di parole per ogni data lunghezza esiste $\delta: X\to Z$ biiettiva tale che preserva la lunghezza delle parole: $\forall x\in X, |\delta(x)|=|x|$.
Allora per ogni codifica $\phi: S \to X, c(X,\phi) = \sum_{s\in S} p(s)|\phi(s)| = \sum_{s\in S} p(s)|\delta(\phi(s))| = c(Z, \delta \circ \phi)$
Dato che per ogni $\psi : S <-> Z, c(Z,\psi)=c(X,\delta^{-1} \circ \psi)$ segue che l'insieme dei costi di X e Z è lo stesso insieme di numeri, $\{c(X,\phi) | \phi:S<->X\} = \{c(Z,\psi) | \psi:S<->Z\}$ e dunque coincide il loro minimo $c(X)=c(Z)$.



Una volta trovato un codice ottimale, possiamo sempre trovare un codice prefisso ottimale. Ma ci manca trovare il codice ottimale:

Prop.
Sia $S=(\mathcal{S},p)$ sorgente, A alfabeto con $\#A=d\ge 2$.
Allora esiste X codice su A ottimale per S.

Dim.
Poiché $d\ge 2$, esistono codici su A di qualsiasi cardinalità finita o numerabile.
Ad esempio, se $a,b \in A, a\neq b$, allora $\{a^kb | 0\le k \le n-1\}$ ha cardinalità $n$.
$a^*b$ è un codice prefisso a cardinalità infinita numerabile.

Sia $Z$ codice adattato a S.
Mostriamo che $\{c(Y)|Y \ codice \ adattato \ a \ S, c(Y)\le c(Z)\}= \mathcal{C}$ è finito. Dopodiché, se dimostriamo che è non vuoto, esiste un minimo.

Sia $\mathcal S_+$ il sottoinsieme di lettere che abbia probabilità positiva.
$\mathcal S_+ = \{s\in \mathcal S | p(s)>0\}$

Sia $\phi: S<-> Z$ tale che $c(Z)=c(Z,\phi)$

Sappiamo $c(Z,\phi)=\sum_{s\in\mathcal{S}}p(s)|\phi(s)|$

Se Y è tale che $c(Y)=c(Y,\psi) \le c(Z)$ allora $\forall s\in \mathcal{S}_+, p(s)|\psi(s)|\le c(Y) \le c(Z) \implies |\psi(s)|\le c(Z)/p(s) \le \dfrac{c(Z)}{min_{t\in \mathcal{S}_+} p(t)} =: M$

Ma l'insieme delle parole su A di lunghezza $\le M$ è finito, l'insieme $\mathcal{C}$ è finito. Poiché $\mathcal {C} \neq \emptyset$, (ci appartiene almeno $c(Z)\in \mathcal C$), segue che $\exists min \ \mathcal C$ e dunque esiste $X$ ottimale per $S$.

A voce, non scritto:  possiamo sempre trovare un codice prefisso ottimale per alfabeti di cardinalità almeno 2.




Dal teorema di Shannon
$\#A=d\ge 2, \phi: \mathcal{S} <-> X, c(X,\phi)=\dfrac{H(S)}{log(d)} \iff X \ massimale \ e \ \forall s\in \mathcal S, p(s)=d^{-|\phi(s)|}$
Se un codice è assolutamente minimale, allora è massimale.

Ma in particolare per $d=2$  basta che sia minimale, non "assolutamente" minimale.
Prop.
Sia $X$ codice prefisso binario ottimale per S sorgente propria (cioè che la distribuzione $p$ sia positiva, $\mathcal{S}=\mathcal{S}_+$). Allora $X$ è massimale.

Dim.
Sia $X$ prefisso binario su $A=\{a,b\}$ non massimale e mostriamo che non è ottimale.

(Se un codice prefisso non è massimale abbiamo visto che questo è equivalente a dire che l'albero minimale che lo rappresenta non è completo)
$T_X$ non è completo e quindi ha almeno un nodo interno con esattamente un figlio: sia $w\in Pref(X)$ tale che $wa \in Pref(X)$ e $wb\notin Pref(X)$.

Tutte le parole che iniziano con $w$ iniziano con $wa$.

Consideriamo $X'=\{wv\in A^*|wav\in X\} \cup (X \setminus {w}A*)$. In pratica prendiamo tutte le parole di X e da quelle che iniziano con $wa$ e togliamo $w$. Stacchiamo il nodo $wa$ e lo attacchiamo al posto del nodo $w$.
![[Pasted image 20251020133854.png]]

$X'$ è codice prefisso su A adattabile a S.

Se $\phi: \mathcal S <-> X$ è tale che $c(X)=c(X,\phi)$ possiamo lasciare invariate le parole che non iniziano con $w$ e togliamo la $a$ alle parole che iniziano con $w$ e quindi con $wa$.
Definiamo $\phi': \mathcal S <-> X'$ da $phi'(s)=\phi(s)$ se $\phi(s) \notin \{w\}A^*$, e se $\phi(s)=wav$, $\phi'(s)=wv$.
Notiamo che ovviamente, stando semplicemente accorciando alcune parole (con probabilità $p(a)>0$), il costo $c(X',\phi')=\sum_{s\in \mathcal{S}}p(s)|\phi'(s)|\lt \sum_{s\in \mathcal{S}}p(s)|\phi(s)|=c(X)$


Immediata conseguenza: stessa cosa vale per i codici non prefissi
Corollario
Sia $X$ codice su $A$ binario ottimale per S. Allora X è massimale.

Dim
Sia $X$ ottimale e sia $Z$ prefisso su $A$ tale che $f_X=f_Z$. Allora $Z$ è ottimale e dunque massimale.
Quindi la sua misura rispetto alla distribuzione uniforme $\pi(Z)=1$.
Ma $1 = \pi(Z)=\sum_{n=0}f_Z(n)d^{-n}= \sum_{n=0}f_X(n)d^{-n}=\pi(X)$ e quindi X è massimale.


Teorema (limite superiore per costo quando la sorgente non permette ottimalità)
Sia $S$ sorgente, $A$ alfabeto di codice con $\#A=d\ge 2$. Allora esiste $X$ codice su $A$ adattato a $S$ tale che $\dfrac{H(S)}{log(d)}\le c(X) \lt \dfrac{H(S)}{log(d)}+1$

Dim (per semplicità dimostriamo solo per sorgenti proprie, ma vale in generale)
Per Shannon, $\dfrac{H(S)}{log(d)}=c(X)\iff$ X massimale e $\forall s \in \mathcal{S}$, $|\phi(s)|=-log_d(p(s))=log_d(\dfrac{1}{p(s)})$, applicando log a entrambi i membri. Ricordiamo che non è sempre possibile avere l'uguaglianza perché devo avere un numero intero.

Definiamo per $s\in \mathcal{S}, r(s)=\lceil log_d(\dfrac{1}{p(s)}) \rceil$
Allora per definizione di soffitto, $log_d(\dfrac{1}{p(s)}) \le r(s) \lt log_d(\dfrac{1}{p(s)})+1$
Da $r(s) \ge -log_d(p(s)), \ d^{-r(s)}\le p(s) \implies \sum_{s\in \mathcal{S}}d^{-r(s)} \le \sum_{s\in\mathcal{S}}p(s)=1$

Per $n \in N$, sia $f(n)=\#\{s\in \mathcal{S} | r(s) = n\}$, cosicché $\sum_{s\in \mathcal{S}}d^{-r(s)} = \sum_{n=0}^{\infty}f(n)d^{-n}$ e poiché S è propria, $\forall s\in \mathcal{S}$, $log_d 1/p(s) \gt 0 \implies r(s) \ge 1$, da cui $f(0)=0$.

$f$ soddisfa le condizioni per essere struttura di codice prefisso (teorema di kraft)
Per teorema di Kraft, esiste $X$ prefisso su $A$ tale che $f_X=f$.
In particolare, $\#X=\#\mathcal S$. Quindi ha senso parlare del costo di $X$ rispetto a $S$.

Allora, definendo una codifica apposita (che esiste data la funzione di struttura), $c(X) \le \sum_{s\in \mathcal{S}} p(s)r(s) \lt \sum_{s\in\mathcal S} p(s)(log_d(\dfrac{1}{p(s)})+1) = \dfrac{H(S)}{log(d)} + \sum_{s\in\mathcal S} p(s)= \dfrac{H(S)}{log(d)} + 1$


In breve, avevamo dimostrato che un codice prefisso binario ottimale per la sorgente, è anche massimale. Si estende anche per non prefissi perché per ogni codice non prefisso si può prendere un codice prefisso con la stessa struttura, che se è massimale ha misura=1 che è la stessa di quello originale non prefisso .